# This is not yet complete
#  vim:sts=2:sw=2:
grammar ObjLang
  rule program
    blank?
    (class_def / stmt / blank)*
    blank? <Program>
  end

  rule stmt
    blank? ( compound_expr / simple_expr nl )
  end

  rule expr
    compound_expr / simple_expr
  end

  rule compound_expr
    meth_def / if_expr
  end

  rule if_expr
    'if' sp expr sp? nl stmts
    blank? if_rest <IfExpr>
  end

  rule if_rest
    elsif_expr / else_expr / (END nl)
  end

  rule elsif_expr
    'elsif' sp expr sp? nl stmts if_rest
  end

  rule else_expr
    'else' sp? nl stmts blank? END nl <ElseExpr>
  end

  rule stmts
    stmt*
  end

  rule simple_expr
    op_app / atomic_expr
  end

  rule op_app
    atomic_expr sp? op sp? simple_expr <OpApp>
  end

  rule atomic_expr
    (
      message / 'true' / 'false' / 'nil' / integer / assignment / varref / parens
    ) ('.' message)*
  end

  rule parens
    '(' sp? simple_expr sp? ')' <Parens>
  end

  rule op
    '+' / '-' / '*' / '/' / '<' / '>' / '<<' / '>>' / '<=' / '>=' / '==' / '&&' / '||'
  end

  # Expressions
  rule class_def
    CLASS sp
    const_id (sp? '<' sp? const_id)? sp? nl
    class_body
    END nl <ClassDef>
  end

  rule class_body
    (stmt / blank)*
  end

  rule meth_def
    DEF sp
    id sp? '(' ( sp? id ( sp? ',' sp? id )* )? sp? ')' nl
    meth_body
    END nl <MethDef>
  end

  rule meth_body
    (stmt / blank)*
  end

  rule message
    varref '(' ( sp? simple_expr ( sp? ',' sp? simple_expr)* )? sp? ')'
  end

  rule assignment
    varref sp? '=' sp? expr <Assignment>
  end

  rule integer
    [0-9]+ <Integer>
  end

  rule varref
    !'def' !'class' !'if' !'elsif' !'else' !'true' !'false' !'nil' !'end' [$@]? id
  end

  # Keywords
  rule CLASS
    'class'
  end

  rule END
    'end'
  end

  rule DEF
    'def'
  end

  # Identifiers
  rule const_id
    [A-Z] [A-Za-z_]* <Identifier>
  end
  rule id
    [A-Za-z_]+ <Identifier>
  end

  # Three different classes of whitespace
  rule sp
    [ \t]+ <Whitespace>
  end
  rule blank
    [ \t\n]+ <Whitespace>
  end
  rule nl
    [\n] <EndExpr>
  end
end
